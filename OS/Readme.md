# [운영체제 원리]
더 자세한 정리는 https://velog.io/@mingming_eee/posts <운영체제 원리> 시리즈에서 확인할 수 있다.


## (1일차) 운영체제와 컴퓨터 하드웨어

### 1. 운영체제란
: 컴퓨터에 포함된 CPU나 메모리, 입출력 기기 등이 사용자의 기대에 맞게 역할을 수행할 수 있도록 도와주는 창구 역할을 하는 시스템 소프트웨어

- 운영체제 대표적인 역할
1. 프로세스 관리
2. 메모리 관리
3. 파일 시스템 관리

- 운영체제 구조
1. 커널
2. 시스템 호출
3. 드라이버

### 2. 컴퓨터 하드웨어 구조

![alt text](image.png)
1. CPU(Central Processing Unit, 중앙처리장치) - ALU, CU, Register Set
2. Main Memory(RAM, Random Access Memory)
3. Bus System(버스 시스템)

### 3. CPU 이해하기

- CPU 구성
1. ALU
2. CU
3. Register Set

- 주요 레지스터
1. 프로그램 카운터 (Program Counter)
2. 인스트럭션 레지스터 (Instruction Register)
3. 어드레스 레지스터 (Address Register)
4. 버퍼 레지스터 (Buffer Register)
5. 플래그 레지스터 (Flag Register)
6. 스택 포인터 (Stack Pointer)

- 클럭 펄스

### 4. 프로그램의 실행과정

- 폰 노이만 구조

- 프로그램의 실행과정
: 프로그램 코드 → 어셈블리 코드 → 바이너리 코드 (컴파일)
→ 보조 메모리 →  메인 메모리 → CPU에 의한 차례대로 처리 (Fetch_Register → Decode_CU → Execution_ALU)

- 데이터 이동 (시스템 버스)
: 데이터 버스, 제어 버스, 주소 버스

### 5. 인터럽트(Interrupt)

- CPU Interrupt: 동기 interrupt, Exception(예외)
- Hardware Interrupt: 비동기 interrupt
- Interrupt Handling: Interrupt Service Routine, Interrupt Handler
<br>

## (2일차) 프로세스

### 1. 프로세스의 이해

- 프로세스란? 실행 중인 프로그램

- 프로세스 구조
1. 명령어가 담긴 코드 영역
2. 전역변수 등이 담긴 데이터 영역
3. 지역변수 등이 담긴 스택 영역
4. 동적 메모리 할당을 위한 힙 영역

- 레지스터
: 프로그램의 실행을 위해서는 레지스터가 절대적으로 필요

### 2. 프로세스 상태

- Process Control Block (PCB)
: 여러 개의 프로세스를 동시에 실행하지 않고, 빠르게 번갈아 가며 실행.
프로세스를 식별하기 위해 필요한 정보들이 저장

- 프로세스 상태
: 생성 → Ready(준비) ↔ Running(실행) → Blocked (대기) → 종료
(대기에서 다시 실행 원할 시 준비 상태로)

- 프로세스 계층
: 부모 프로세스, 자식 프로세스 (각각의 독립적인 영역)

### 3. 컨텍스트 스위칭(Context Switching)
: 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 데이터로 교체하는 작업.
프로세스 컨트롤 블록에는 프로세스의 상태나 다음 실행할 명령어와 같은 각종 레지스터 값이 포함되어 있다. 
따라서 프로세스 컨트롤 블록의 내용을 잘 관리하면 여러 개의 프로세스를 효율적으로 작동시킬 수 있다.

### 4. 프로세스 생성
: 최초의 프로세스 (부모 프로세스) → fork() → 자식 프로세스 → exec() → 각각의 독립적인 프로세스 계층 구조 완료

### 5. 스레드의 이해
: 프로세스는 스레드를 두어 작업을 나누어 처리하고, 컨텍스트 스위칭이 줄어들기 때문에 운영체제에 부담이 훨씬 줄어들어 효율적.
스레드는 스레드가 하나 생성될 때마다 스레드를 위한 스택 영역이 추가로 생성될 뿐, 그 이외의 영역은 프로세스의 영역을 공유 (코드 영역, 데이터 영역, 힙 영역)

### 6. CPU 스케줄링
: CPU는 여러 개의 프로세스를 빠르게 번갈아 실행하기 위해 각 프로세스를 위해 일하는 시간을 조금씩 나누어 배분
프로세스 별로 요구하는 자원이 상이하기 때문에 운영체제(스케줄러)가 각 상황에 맞게 운영체제는 프로세스마다 우선순위를 부여하고 이를 기준으로 프로세스를 실행

- Process Scheduling(프로세스 스케줄링)
- 프로세스 우선순위

<br>

## (3일차) 프로세스 통신과 동기화

### 1. 스케줄링 알고리즘

#### 01. Queue (큐)
: 운영체제는 준비 상태의 프로세스와 대기 상태의 프로세스를 관리하기 위해 스케줄링 큐 (Scheduling Queue) 자료구조를 사용

#### 02. 큐 자료구조 동작
: 운영체제는 큐에 서있는 순서대로 프로세스 컨트롤 블록을 하나씩 참조하면서 프로세스를 실행.
우선순위가 높은 프로세스가 등장하게 되면 아래 그림처럼 새치기를 허용.

#### 03. 스케줄링 알고리즘
- 스케줄링 알고리즘 적용시 고려해야 할 사항
1) 부하가 최소화 (컨텍스트 스위칭 최소화)
2) 컴퓨팅 자원(CPU 또는 입출력 장치)의 사용을 효율적으로 분배
3) 균형잡힌 스케줄링 필요
4) 대기 및 응답 시간이 너무 길지 않게

- 스케줄링 알고리즘 종류
1) 선입 선출 (First In First Out)
2) 최단 작업 우선 (Shortest Job First)
3) 라운드 로빈 (Round Robin)
4) 우선순위 스케줄링 (Priority Scheduling)

### 2. 프로세스 간 통신 (Inter-Process Communication, IPC)
: 프로세스는 독립적으로 실행되지만, 필요 시 다른 프로세스와 데이터를 주고받는 것

- 방식
1) 메일 슬롯 방식 (Mail Slot Method)
2) 파이프 방식 (Pipe Method)

### 3. 동기화
: 동시다발적으로 작업을 처리하면 문제가 발생할 수 있어 프로세스 동기화 작업이 반드시 필요

- 공유 자원
- 임계 구역
- 상호 배제
- 동기화 기법 종류
1) 뮤텍스 락 (Mutex) : acquire(), release()
2) 세마포어 (Semaphore) : wait(), signal()

### 4. 데드락 (Deadlock)
: 프로세스 실행 과정에서 발생할 수 있는 정체 상황을 Deadlock (데드락), '교착 상태'

- 데드락 조건
1) 상호 배제 (Mutual exclusion)
2) 비선점 (No preemption)
3) 점유 및 대기  (Hold and wait)
4) 원형 대기 (Circular wait)

<br>

## (4일차) 메모리와 페이지 교체

### 1. 메모리의 이해

### 2. 가상 메모리 관리

### 3. 페이지 교체

<br>

## (5일차) 파일과 디렉터리

### 1. 파일

### 2. 디렉터리

### 3. 파일과 메모리

<br>

## (부록)

### 1. 데이터 표현

### 2. 스레드풀(Thread Pool)

### 3. 라운드로빈 모델(Round Robin - RR model)
## 연결 리스트 (Linked List)
: 추상적 자료형인 리스트를 구현한 자료구조로 어떤 데이터 덩어리를 저장할 때 그 다음 순서의 자료가 있는 위치를 데이터에 포함시키는 방식으로 자료를 저장한다. 쉽게 생각하면 자료를 비엔나 소시지마냥 줄줄이 엮어놓은 것이다.

### [종류]
1. 단순 연결 리스트 (Singly Linked List)
다음 노드에 대한 참조만을 가진 가장 단순한 형태의 연결 리스트이다. 가장 마지막 원소를 찾으려면 얄짤없이 리스트 끝까지 찾아가야 하기 때문에(O(n)), 마지막 원소를 가리키는 참조를 따로 가지는 형태의 변형도 있다. 보통 큐(Queue)를 구현할 때 이런 방법을 쓴다.
이 자료구조는 Head 노드(첫번째 데이터 노드)를 참조하는 주소를 잃어버릴 경우 데이터 전체를 못 쓰게 되는 단점이 있다. 다음 노드를 참조하는 주소 중 하나가 잘못되는 경우에도 체인이 끊어진 양 거기부터 뒤쪽 자료들을 유실한다. 따라서 안정적인 자료구조는 아니다.
파일 시스템 중 FAT 파일 시스템이 이 단순 연결 리스트로 파일 청크를 연결하는데 그래서 FAT 파일 시스템은 파일 내용 일부가 손상될 경우 파일의 상당 부분을 유실할 수 있고 랜덤 액세스 성능도 낮다.

2. 이중 연결 리스트 (Doubly Linked List)
다음 노드의 참조뿐만 아니라 이전 노드의 참조도 같이 가리키게 하면 이중 연결 리스트가 된다. 뒤로 탐색하는 게 가능하다는 단순한 장점 이외에도 한 가지 장점이 더 있는데, 단순 연결 리스트는 현재 가리키고 있는 노드를 삭제하는 게 한 번에 안 되고 O(n)이 될 수밖에 없는데 비해 이중 연결 리스트에서 현재 노드를 삭제하는 것은 훨씬 간단하다. 대신 관리해야 할 참조가 두 개나 있기 때문에 삽입이나 정렬의 경우 작업량이 더 많고 자료구조의 크기가 약간 더 커진다.

단일 연결 리스트보다는 손상에 강한 편이다. Head 노드(첫번째 노드)와 Tail 노드(마지막 노드)를 갖고 있다면 둘 중 하나를 가지고 전체 리스트를 순회할 수 있기 때문에 끊어진 체인을 복구하는 게 가능하다. 단점은 이런 보정 알고리즘을 구현하지 않았을 경우에는 오히려 손상에 더 취약해진다는 것이다. 예를 들어 노드의 next 포인터 (다음 노드의 메모리 주소를 갖는 포인터, 즉 다음 노드를 가르키는 포인터)는 갱신을 했는데 prev 포인터(이전 노드를 가르키는 포인터)는 갱신하지 않았을 경우 prev포인터를 따라가는 순회에서 도달 불가능한 '잃어버린' 노드가 발생한다.

3. 순환 연결 리스트 (Circular linked list)
단순 연결 리스트 (Singly linked list)에서 마지막 원소(노드)가 널 (Null) 대신 처음 원소를 가리키게 하면 순환 연결 리스트가 된다. 이와 비슷하게, 이중 연결 리스트 (Doubly linked list)의 처음과 끝을 서로 이으면 이중 순환 연결 리스트를 만들 수 있다.이미 할당된 메모리 공간을 삭제하고 재할당하는 부담이 없기 때문에 큐를 구현하는 데에도 적합하다.

4. 청크 리스트(Chunked List)
배열과 리스트의 장점을 합친 것. 리스트의 멤버가 배열이다. CPU에 캐시 기능이 있는 경우 지역성Locality이 떨어지는 연결 리스트는 심각한 성능 저하를 불러온다. 이를 보완하기 위해 리스트의 멤버를 레코드의 배열로 하는 것이다. 이 청크 리스트의 발전형이 바로 B+tree다.

### [구현 방법]
일반적으로 구조체와 그 포인터로 구성된다.

- C언어에서의 활용
```c
struct Linked_List 
{
    int number;
    char name[20];
    ...
    struct Linked_List *next;
};
```
연결리스트 데이터 하나의 노드는 구조체 인스턴스 한 개에 대응한다. 이 안에 넣고자 하는 데이터(숫자, 문자 등등...)을 넣고, 거기에 (이전 노드와) 다음 노드의 위치를 표시해주는 포인터를 포함시키면 연결리스트가 정의된다. 위 예시는 단일 연결 리스트의 예로서, 여기에서 Previous를 추가하면 이중 연결 리스트가 된다.
```c
struct Linked_List* Previous;
```
사용할 때는 head->next->next->name 하는 식으로 사용한다. 노드 조회 메서드 예시는 아래와 같다.
```c
List * get(int index) 
{
  List *head = HEAD;
  List *cur = head;

  for(int i=0; i<index; ++i) 
  {
    cur = cur->next;
  }
  return cur;
}
```
특이할 점은 노드 자신의 위치를 표시하기 위한 자기참조 구조체라는 개념이다. 자기 자신을 구조체 멤버로 가지지 못하는 대신 자기 자신 타입의 포인터를 멤버로 가짐으로써, 스스로의 주소값을 표현하는 것이다. 구조체는 항상 고정 크기의 메모리 공간을 할당받아야 하는데 자기 자신을 멤버로 가진다면 그 '고정 크기'를 알 수 없기 때문에 자기 자신을 멤버로 가지지 못한다. 그러나 자기 자신에 대한 포인터는 크기가 항상 4바이트(32비트 OS)나 8바이트(64비트 OS)로 같다. 그래서 구조체의 전체 크기를 계산 가능하다.